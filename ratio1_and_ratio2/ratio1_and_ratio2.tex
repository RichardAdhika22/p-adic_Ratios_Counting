%% Standard start of a latex document
\documentclass[letterpaper,12pt]{article}
%% Always use 12pt - it is much easier to read
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{float}

%% AMS mathematics packages - they contain many useful fonts and symbols.
\usepackage{amsmath, amsfonts, amssymb}


%% The geometry package changes the margins to use more of the page, I suggest
%% using it because standard latex margins are chosen for articles and letters,
%% not homework.
\usepackage[paper=letterpaper,left=25mm,right=25mm,top=3cm,bottom=25mm]{geometry}
%% For details of how this package work, google the ``latex geometry documentation''.
\usepackage{amsthm}
\usepackage{geometry}
\geometry{
  left=0.7in,
  right=0.7in,
  top=0.8in,
  bottom=1in
}

\newtheorem{lemma}{Lemma}
\usepackage{enumerate}
%%
%% Fancy headers and footers - make the document look nice
\usepackage{fancyhdr} %% for details on how this work, search-engine ``fancyhdr documentation''
% \pagestyle{fancy}
%%
%% This is a little more complicated because we have used `` \\ '' to force a line-break between the name and number.
%%
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\bigO}{\mathcal{O}}
\newcommand{\GL}{\mathbf {GL}}

\cfoot{Page \thepage} % page in middle

%% These put horizontal lines between the main text and header and footer.
\renewcommand{\footrulewidth}{0.4pt}
%%%

\begin{document}

\begin{center}
    {\bf \LARGE Ratio 1 and Ratio 2} \\
    Richard Adhika
\end{center}

\

{\bf \LARGE 1. Introduction}

\

For reasons coming from number theory, we are interested in computing the following two kinds of (closely related) ratios, for different primes $p$: 
Let $t$ and $d$ be integers.  

The first ratio is 
\[
\nu_{p, n} (t, d) = \frac{\#\{M\in \GL_2(\Z/p^n\Z) \vert M \text{ has trace } t \text{ and }  \det  D  \mod p^n\} }{p^{2n-2}(p^2-1)}.
\]

This ratio is really interesting only when the \emph{discriminant} of the characteristic polynomial, i.e., 
$t^2-4D$, is divisible by $p$ (and they get more interesting as the power of $p$ dividing the discriminant gets larger). 
These stabilize when $n$ gets large (if $p$ doesn't divide the discriminant, they stabilize right away). 
However,  we understand these quite well. We are more interested in the ones that come no from counting solutions $\mod p^n$, but from counting the \emph{reductions  $\mod p^n$ of solutions in $\Z_p$}. 
More precisely, we define 
\[
\mu_{p, n} (t, d) = \frac{\#\{M\in \GL_2(\Z/p^n\Z) \vert \exists M'\in \GL_2(\Z_p):  M' \text{ has trace } t \text{ and }  \det  D, \text { and } M' \bmod p^n = M \} } 
{p^{2n-2}(p^2-1)}.
\]

Since we cannot really handle full $p$-adic series in a computer code, we introduce another parameter, "kbig" or something (also user-defined), and compute 
\[
\mu_{p, n} (t, d) = \frac{\#\{M\in \GL_2(\Z/p^n\Z) \vert \exists M'\in \GL_2(\Z/p^{kbig}\Z):  M' \text{ has trace } t \text{ and }  \det  D, \text { and } M' \bmod p^n = M \} } 
{p^{2n-2}(p^2-1)}.
\]

Again these stabilize eventually (as $n$ gets large, but we need $kbig>>n$), and again they are only interesting when a power of $p$ divides the discriminant (when it doesn't, these also stabilize at $n=1$ and are equal to $\nu_p$). 
We want to know these numbers for various values of $t$, $d$, and $p$.
The problem is that even if you let $p=5$ and $kbig=6$, it is already taking forever to compute 
(using brute force method). 

\vspace{0.6in}

{\bf \LARGE 2. Ratio 1}

\

We first want to try to generate all matrices of the form 
\[
\begin{pmatrix}
a & b \\ c & d
\end{pmatrix}
\]
with $d \equiv t - a \bmod p^n$ and $ad - bc \equiv D \bmod p^n$ 
for $a,b,c,d \in \Z/p^n\Z$.
Here, we have 3 free parameters $a,b$, and $c$ since $d$ depends solely on $a$ for the given $t$.
The naive brute force method is to loop
through $[0, p^n-1]$ for each $a,b,c$ and then check the determinant condition.
This takes $\bigO(p^{3n})$, which is very slow.
Hence, the function \texttt{build\_matrices1} in the file 
\emph{ratio1\_and\_ratio2.ipynb} aims to 
generate the matrices more efficiently 
(the pseudocode of the function is provided on the next page).

\

For the parameter $a$, we will still loop through $[0, p^n-1]$.
First, fix an $a$.
Let rhs$ = ad-D \bmod p^n$.
Then, for any $b \in [0, p^n-1]$,
the problem turns into solving the equation (for $c$)
\begin{equation}
bc \equiv rhs \bmod p^n .
\end{equation}
If $p \nmid b$, then $b^{-1}$ exists and thus 
we have a unique solution
$c \equiv rhs \cdot b^{-1} \bmod p^n$ (line 6).
We don't need to loop through $c$ for these $b$.
If $p \mid b$, then we have three cases as follows,

\begin{enumerate}
\item $p \nmid rhs$. This immediately tell us that (1) can't have any solution 
if $p \mid b$. This corresponds to the facet that the loop in line 9 won't execute.

\item $v_p(rhs) \geq 1$.
If $v_p(b) > v_p(rhs)$, then (1) also can't have any solution.
Hence, it suffices to check $b$ with $1 \leq v_p(b) \leq v_p(rhs)$ (line 10 with $v_p(b) = i$).
Also $v_p(rhs) < n$ so the modulo is well-defined.
Then, for each $i$, let $b = p^i j$ so that we can rewrite (1) as 
\[
p^i j \cdot c \equiv rhs \bmod p^n,
\]
We then get $c \equiv (rhs / p^i) \cdot j^{-1} \bmod p^{n-i}$, 
for which we lift $c$ to modulo $p^n$.

\item $rhs \equiv 0 \bmod p^n$.
Then, we can set $b=0$ so that all $c \in [0, p^n-1]$ satisfy (1) (line 14-16).
Furthermore, for any $b$, 
all $c$ with $v_p(c) = n-v_p(b)$ satisfy (1) (line 17 - 19). 
\end{enumerate}

\begin{algorithm}[H]
\caption{build\_matrices1}
\begin{algorithmic}[1]
\Function{build\_matrices1}{$n, p, t, D$}
    \State $res \gets$ [ ], $Rn \gets \Z/p^n\Z$    
    \ForAll{$a \in Rn$}
        \State $rhs \gets Rn(D - a(t-a))$
        \State Add all tuples $(a,b,c,d)$ to $res$ such that $c \equiv rhs \cdot b^{-1} \bmod p^n$ with $p \nmid b$. \\
        
        \If{rhs $\neq 0$}
            \For{$i = 1$ to $v_p(rhs)$}
                \For{$b \in Rn$ with $b = p^ij$ with $p \nmid j$}
                    \State Add $(a,b,c,d)$ to $res$ with $c \in Rn$ satisfying $c \equiv rhs \cdot j^{-1} \bmod p^{n-i}$
                \EndFor
            \EndFor
        \Else
            \ForAll{$c \in R$}
                \State Add $(a,0,c,d)$ to $res$
            \EndFor

            \For{$b \in Rn$ with $v_p(b) = i \geq 1$}
                \State Add $(a,b,c,d)$ to $res$ with $c \in Rn$ satisfying $v_p(c) = n-i$
            \EndFor
        \EndIf
    \EndFor
    \State \Return $res$
\EndFunction
\end{algorithmic}
\end{algorithm}

Assuming $n$ is not large, this algorithm costs $\bigO(p^{2n})$,
Notice that in the second case, we have that the number of matrices 
with $b = b'$ satisfying $v_p(b') = v$ is the same as that of $b = p^v$
as the loops in line 9-11 has the same step size.
which is already quite an improvement from the brute force algorithm.

\

Now, we can modify this algorithm a bit if we only want to \emph{count} the number of matrices
satisfying the numerator condition.
The few points that we obtained so far are:
\begin{itemize}
\item For each $a$, there are $p^{n-1}(p-1)$ $b$'s that are relatively prime to $p$.
Each of these $b$ produces exactly one matrix.
Hence, we have $p^{2n-1}(p-1)$ matrices in total with $p \nmid b$.
\item For each $a$, if rhs has $p$-valuation $k$, then there are 
\[
\sum_{i=1}^k p^{n-i-1} \cdot (p-1) \cdot p^i = k p^{n-1}(p-1)
\]
many solutions that corresponds to $b$ with $v_p(b) \geq 1$.
The term $p^{n-i-1}(p-1)$ comes from the number of $b$
with $v_p(b) = i$
and the term $p^i$ comes from lifting the modulo from $p^{n-i}$ to $p^n$.
\item For each $a$, if rhs $\equiv 0 \bmod p^n$, then there are 
\[
p^n + \sum_{i=1}^{n-1} p^i (p^{n-i} - p^{n-i-1})
= p^n + (n-1) (p^n - p^{n-1})
\]
many solutions corresponds to $b$ with $b = 0$ and $v_p(b) \geq 1$.
\end{itemize}

With these in mind, we then write a function \texttt{ratio1}
that count the number of matrices satisfying the numerator condition in $\bigO(p^n)$,.
The code is as follows,
\begin{algorithm}[H]
\caption{ratio1}
\begin{algorithmic}[1]
\Function{ratio1}{$n, t, D$}
    \State $count \gets p^n \cdot p^{n-1} \cdot (p - 1)$, $Rn \gets \text{Integers}(p^n)$
    \ForAll{$a \in R$}
        \State $rhs \gets Rn(a(t-a) - D)$

        \If{$rhs \neq 0$}
            \State $count \gets count + v_p(b) \cdot p^{n-1} \cdot (p - 1)$
        \Else
            \State $count \gets count + p^n + (n - 1) \cdot (p^n - p^{n-1})$
        \EndIf
    \EndFor
    \State \Return $count$
\EndFunction
\end{algorithmic}
\end{algorithm}

\newpage

{\bf \LARGE 3. Ratio 2}

\

For the second ratio, however, we still need to generate the matrices 
as the reduction from $kbig$ to $n$ may not include every matrix that satisfies the constraint 
in $\Z / p^n\Z$ (which is true if $p^l | t^2-4D$ for some $l \in \mathbb{N}$).
The problem now is that generating and storing all such matrices takes 
up a lot of time and space (e.g. for $p=5$ and $kbig=5$, we have around 11 million matrices
and for $kbig=6$, CoCalc runs out of space).

\

What if we don't actually need to generate all the matrices?
The first observation is that 
\begin{lemma}
For any matrix $M = \begin{pmatrix} a & b \\ c & d \end{pmatrix}$
with entries in $\Z/p^{kbig}\Z$,
if $p \nmid b$, we only need to consider $a, b \in [0, p^n-1]$.
\end{lemma}
\begin{proof}
Consider two matrices $\begin{pmatrix} a_1 & b_1 \\ c_1 & d_1 \end{pmatrix}$ and
$\begin{pmatrix} a_2 & b_2 \\ c_2 & d_2 \end{pmatrix}$
with $p \nmid b_1, b_2$.
Let $rhs = a_1d_1-D \bmod p^{kbig}$.
Then, the modular equation $b_1c_1 \equiv rhs \bmod p^{kbig}$ has a unique solution 
$c_1 \equiv rhs \cdot b_1^{-1} \bmod p^{kbig}$ .
Furthermore, the modular equation $b_2b_3 \equiv rhs \bmod p^{kbig}$
also has a unique solution $b_3 \equiv rhs \cdot b_2^{-1} \bmod p^{kbig}$.
Assume that $b_2 \equiv b_1 \bmod p^n$ and $a_2 \equiv a_1 \bmod p^n$.
We therefore have
\[
d_2 \equiv t-a_2 \equiv t-a_1 \equiv d_1 \bmod p^n
\] 
and
\[
c_2 \equiv (a_2d_2 - D)b_2^{-1} 
\equiv (a_1d_1 - D)b_1^{-1} 
\equiv c_1 \bmod p^n.
\]
Hence all $a,b \geq p^n$ with $p \nmid b$ will not 
produce any new reduced matrix.
\end{proof}

This means that the reduction does not affect the existence and uniqueness of matrices 
for $b$ with $p \nmid b$.
Therefore, just as the first ratio, we don't need to consider these $b$'s
and that the count for these matrices is $p^{2n-1}(p-1)$.
Next, we have

\

\begin{lemma}
Let $A$ be the set of all $M \in \GL_2(\Z/p^n\Z)$ 
such that there exists $M' \in \GL_2(\Z/p^{kbig}\Z)$ having 
trace $t$ and determinant $D$, and that $M \equiv M' \bmod p^n$
(the numerator condition).
Let $S \subset A$ with $b = p^v$ and
$S' \subset A$ with $b = p^vu$ for some fixed $u$ with $p \nmid u$
and $v < n$.
Then, $|S| = |S'|$.
\end{lemma}


\begin{proof}
Let $v \in [1, n-1]$ and $M = \begin{pmatrix}
a & p^v \\ c & d
\end{pmatrix} \in S$.
Define a map $\phi: S \to S'$ by 
\[
\phi(M) = N = \begin{pmatrix}
a & p^vu \\ cu^{-1} & d
\end{pmatrix}.
\]
First, we want to show that this mapping is well-defined 
by showing that $N \in S'$.
By definition of $M$, there exists $M' \in \GL_2(\Z/p^{kbig}\Z)$
of the form $M' = \begin{pmatrix}
a' & b' \\ c' & d'
\end{pmatrix}$ having trace $t$ and determinant $D$ and
that $M' \equiv M \mod p^n$.
Let 
\[
U = \begin{pmatrix}
1 & 0 \\ 0 & u
\end{pmatrix}, \;
U^{-1} = \begin{pmatrix}
1 & 0 \\ 0 & u^{-1}
\end{pmatrix}.
\]
Let $N' \in \GL_2(\Z/p^{kbig}\Z)$ be defined by 
\[
N' = U^{-1}MU 
= \begin{pmatrix}
a' & b'u \\ c'u^{-1} & d'
\end{pmatrix}.
\]
Then, $N'$ has trace $t$ and determinant $D$, and that 
$b'u \equiv p^v u \bmod p^n$.
Hence, $N = N' \bmod p^n \in S'$.

\

We then want to show that this mapping is injective.
Let $M_1, M_2 \in S$ of the form 
\[
M_1 = \begin{pmatrix}
a_1 & p^v \\ c_1 & d_1
\end{pmatrix}, 
M_2 = \begin{pmatrix}
a_2 & p^v \\ c_2 & d_2
\end{pmatrix}.
\]
Assume that $\phi(M_1) = \phi(M_2)$.
Hence, we have 
\[
\begin{pmatrix}
a_1 & p^v u \\ c_1u^{-1} & d_1
\end{pmatrix} = \begin{pmatrix}
a_2 & p^v u \\ c_2u^{-1} & d_2
\end{pmatrix}
\]  
Since $p \nmid u$ and $p \nmid u^{-1}$, the equality $M_1 = M_2$ follows.

\

Finally, we want to show that the map is surjective.
Let $N = \begin{pmatrix}
a & p^v u \\ cu^{-1} & d
\end{pmatrix} \in S'$ (any matrix in $S'$ can be written in this form).
Let $M = \begin{pmatrix}
a & p^v \\ c & d
\end{pmatrix}$.
If $N'$ is the lift of $N$, then we define 
$M' = U^{-1}N'U$ and a similar argument from the previous paragraph 
shows that $M \equiv M' \bmod   p^n$.
Hence $M \in S$ and that $\phi(M) = N$ 
so that $\phi$ is surjective.
Finally, we conclude that $\phi$ is a well-defined bijection 
between $S$ and $S'$ so that $|S| = |S'|$.
\end{proof}


\

By Lemma 2, for ratio 2, we only need to 
consider the reduced matrices with $b = p^v$ for $1 \leq v < kbig$ and $b = 0$.
% The function \texttt{ratio2}, which counts the number of matrices 
% satisfying the numerator condition, first go through $j$ from 1 to $n-1$,
% and then for each $j$, we loop through $a$ from 0 to $p^{kbig} - 1$
% and check all corresponding $b$ in $[0, p^{kbig}]$ with $v_p(b) = j$
% and $b \equiv p^j \mod p^n$.
Before going to the main function \texttt{ratio2}, we will take a look more closely 
at two helper functions: \texttt{ratio2\_adder} and \texttt{ratio2\_adder\_with\_check},
which reduce a lot of repetitions (of $b$ and $c$) to make the program more efficient.
Below is the code for the function \texttt{helper\_fn}.

\begin{algorithm}[H]
\caption{Helper Function 1}
\begin{algorithmic}[1]
\Function{ratio2\_adder}{$p, n, kbig, \text{projset}, \text{rhs\_new}, a, \text{ind}, \text{exp}$}
    \State $R_n \gets \mathbb{Z}/p^n\mathbb{Z}$
    \State $c_{\text{start}} \gets \left( \frac{\text{rhs\_new}}{\text{ind}} \right) \bmod p^{k_{\max} - \text{exp}}$
    \If{$\big( R_n(a),\; R_n(c_{\text{start}}),\; R_n(d) \big) \in \text{projset}$}
        \State \Return \textbf{false}
    \EndIf
    \State Add $\big( R_n(a),\; R_n(c_{\text{start}}),\; R_n(d) \big)$ to \text{projset}
    \For{$c$ from $c_{\text{start}} + p^{k_{\max} - \text{exp}}$ to $p^n - 1$ step $p^{k_{\max} - \text{exp}}$}
        \State Add $\big( R_n(a),\; R_n(c),\; R_n(d) \big)$ to \text{projset}
    \EndFor
    \State \Return \textbf{true}
\EndFunction
\end{algorithmic}
\end{algorithm}

Note that we use this function only for $j < n$.
The parameter rhs\_new in this function denotes 
$\frac{ad-D}{p^j}$, ind denotes $\frac{b}{p^j}$ with 
$p \nmid $ ind, and exp denotes $j$ (we will still use $j$ in the explanation below, 
the use of $exp$ is just for code readability).
If this helper function returns false, then we stop the loop 
of $b$ and immediately proceed to the next $a$ in the function \texttt{count\_matrices2}.
What this is saying is that if we encounter one reduced matrix 
that has been considered before (either for smaller $a$ or $b$),
then there is no need to check further $b$ or $c$ for this fixed $a$.

\

Let $M = \begin{pmatrix} a & b \\ c & d \end{pmatrix}$ 
be the matrix that we are considering
with entries in $\Z / p^{kbig}$ and
$M' = \begin{pmatrix} a' & b' \\ c' & d' \end{pmatrix}$
with $M \equiv M' \bmod p^n$ and $v_p(b) = v_p(b') = j$.
We start with a more obvious simplification first, which is that 
for this particular $a$ and $b$,
there is no need to consider $M$ with $c + sp^{kbig-j}$ for any $s \in \mathbb{N}$
since it will also be congruent to $M'$ with $c' + sp^{kbig-j}$.
This also applies for $j \geq n$.

\

With this, we want to show that 
\begin{lemma}
If $M$ is the first matrix that satisfies the congruence for this particular $a$, then
$a > a'$ if and only if $b = p^j$.
Furthermore, we don't need to consider any $b_0 > b$ for this particular $a$.
\end{lemma}

\begin{proof}
It is clear that if $b = p^j$, then $a > a'$ since
otherwise if $a = a'$, then $b > b'$ so that $b \neq p^j$.
Now assume that $a > a'$ and $b = p^j u $ 
for some $u > 1$ and $p \nmid u$.
We can then write $b' = p^j \beta' u$, $c' = \gamma' u^{-1}$, and 
$c = \gamma u$. We have 
\[
\begin{pmatrix} a & p^j u \\ \gamma u^{-1} & d \end{pmatrix}
\equiv \begin{pmatrix} a' & p^j \beta' u \\ \gamma' u^{-1} & d' \end{pmatrix} \bmod p^n.
\]
We can "remove" $u$ and $u^{-1}$ and the modular equation above will still hold.
That is,
\[
\begin{pmatrix} a & p^j \\ \gamma & d \end{pmatrix}
\equiv \begin{pmatrix} a' & p^j \beta'\\ \gamma' & d' \end{pmatrix} \bmod p^n.
\]
Hence, the reduced form of the matrix on the left hand side has also been considered before 
so that we get $b = p^j$.
Then, for any $v \in \mathbb{N}$ with $p \nmid v$, we have 
\[
\begin{pmatrix} a & p^jv \\ \gamma v^{-1} & d \end{pmatrix}
\equiv \begin{pmatrix} a' & p^j \beta'v\\ \gamma'v^{-1} & d' \end{pmatrix} \bmod p^n
\]
so that we don't need to consider any $b > p^j$ anymore
(as we don't need to consider all corresponding $c$'s as well).
\end{proof}

\

Furthermore, we also have 
\begin{lemma}
If $a = a'$, and $M$ is the first matrix that satisfies the congruence,
then we don't need to consider all $b_0 > b$. 
\end{lemma}
\begin{proof}
Since $b > b'$, let $b = b' + k p^l$ for some $k \in \mathbb{N}$.
Note that for $j < n$, $l = n$, otherwise, $l = j$ as we only consider those 
$b$ with reduced form being $p^j$.
Let $g = \frac{ad-D}{p^j}, r = (b / p^j)^{-1} = (b' / p^j + kp^{l-j})^{-1}$, and 
$r' = (b' / p^j)^{-1}$.
Then we have $c \equiv gr \bmod p^{kbig}$ and $c' \equiv gr' \bmod p^{kbig}$.
Hence, we have
\[
g(b' / p^j + kp^{l-j})^{-1} \equiv g(b' / p^j)^{-1} \bmod p^n
\]
so that 
\[
kp^{l-j} \equiv 0 \bmod p^{\max(0, n - v_p(g))}.
\]
Since $M$ is the first such matrix, $k = p^{\max(0, n-l+j - v_p(g))}$
and $b' = p^j$. 
Since all $b_0 > b$ have the form $b_0 = b'+ (k+k_0)p^l$ with $k_0 \in \mathbb{N}$,
and that 
\[
g(1 + (k+ k_0)p^{l-j})^{-1} \equiv g(1 + k_0p^{l-j})^{-1} \bmod p^n,
\]
all matrices of the form 
$\begin{pmatrix} a & b_0 \\ c_0 & d \end{pmatrix}$
have its reduced form been considered earlier.

\end{proof}

By Lemma 3 and Lemma 4, for a fixed $a$, we don't need 
to consider further $b$ and $c$ values once we know that we 
have encountered the reduced form before.

\

Below is the code for the function \texttt{helper\_fn2}.

\begin{algorithm}
\caption{\textsc{Helper\_fn2}$(p, n, k_{\max}, \text{projset}, \text{lift}, \text{rhs\_new}, a, \text{ind}, d, \text{exp})$}
\begin{algorithmic}[1]
\State $R_n \gets \mathbb{Z}/p^n\mathbb{Z}$
\State $R_{k_{\max}} \gets \mathbb{Z}/p^{k_{\max}}\mathbb{Z}$
\State $c_{\text{start}} \gets \bigl( \frac{\text{rhs\_new}}{\text{ind}} \bigr) \bmod p^{k_{\max} - \text{exp}}$

\If{$(R_n(a),\ R_n(c_{\text{start}}),\ R_n(d)) \in \text{projset}$}
    \State $\text{lifted} \gets \text{lift}[(R_n(a),\ R_n(c_{\text{start}}),\ R_n(d))]$
    \If{$\text{lifted}[1] = 0$ \textbf{or} $\text{valuation}_p(\text{lifted}[1]) = \text{exp}$}
        \State \Return \textbf{false}
    \EndIf
\EndIf

\State $\text{projset} \gets \text{projset} \cup \{(R_n(a), R_n(c_{\text{start}}), R_n(d))\}$
\State $\text{lift}[(R_n(a), R_n(c_{\text{start}}), R_n(d))] \gets (a,\ R_{k_{\max}}(p^{\text{exp}} \cdot \text{ind}),\ c_{\text{start}},\ d)$

\For{$c$ \textbf{from} $c_{\text{start}} + p^{k_{\max} - \text{exp}}$ \textbf{to} $p^n - 1$ \textbf{step} $p^{k_{\max} - \text{exp}}$}
    \State $\text{lift}[(R_n(a), R_n(c), R_n(d))] \gets (a,\ R_{k_{\max}}(p^{\text{exp}} \cdot \text{ind}),\ c,\ d)$
    \State $\text{projset} \gets \text{projset} \cup \{(R_n(a), R_n(c), R_n(d))\}$
\EndFor

\State \Return \textbf{true}
\end{algorithmic}
\end{algorithm}

The only different things here is that we now have a dictionary called
\texttt{lift} that keeps track on the pairing between the reduced matrix
(entries in $\Z/p^n$) and the original matrix (entries in $\Z/p^{kbig}$).
This is done to make sure that Lemma 2 and Lemma 3 work as 
we require the assumption that $v_p(b) = v_p(b')$.
Furthermore, if $b' = 0$, this means that we have covered 
all possible reduced form of $c$, so we don't need to 
check anything for current $a$.
As a sidenote, all the examples I ran works perfectly fine 
without this helper function, meaning that one of
$v_p(b) = v_p(b')$ or $b' = 0$ is guaranteed in this case.
However, I am still having trouble proving it so I am still using this 

% \

\end{document}
